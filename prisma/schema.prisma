generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                 String   @id @default(uuid())
  createdAt          DateTime @default(now())
  companyName        String?  @unique @db.VarChar(1000)
  companyEmail       String   @unique @db.VarChar(1000)
  companyEmailHashed String   @unique @db.VarChar(255)

  // ==================== AUTHENTICATION ====================
  // Currently implemented: LOCAL (email/password)
  // Future: Google OAuth, Facebook OAuth
  password            String?
  hasPassword         Boolean  @default(false)
  primaryAuthProvider Provider @default(LOCAL)
  googleId            String?  @unique
  facebookId          String?  @unique

  outlets      Outlet[]
  staffs       Staff[]
  logo         String?      @db.VarChar(255)
  oAuthTokens  OAuthToken[]
  queues       Queue[]
  slug         String       @unique @db.VarChar(255)
  customers    Customer[]
  auditLogs    AuditLog[]
  businessType BusinessType @default(BASIC)

  // ==================== PDPA COMPLIANCE ====================
  // Status: IMPLEMENTING 22/11/2026
  privacyPolicyAccepted   Boolean   @default(false)
  privacyPolicyAcceptedAt DateTime?
  privacyPolicyVersion    String?   @db.VarChar(50)

  // ==================== STRIPE PAYMENTS ====================
  // Status: NOT YET IMPLEMENTED
  // Planned for: Phase 2 (Q2 2026)
  stripeCustomerId      String?            @unique @db.VarChar(255) // Stripe customer ID (cus_xxx)
  stripeSubscriptionId  String?            @unique @db.VarChar(255) // Current subscription ID (sub_xxx)
  subscriptionStatus    SubscriptionStatus @default(FREE)
  subscriptionTier      SubscriptionTier   @default(FREE)
  subscriptionStartDate DateTime?
  subscriptionEndDate   DateTime?
  trialEndsAt           DateTime? // Free trial end date
  subscriptions         Subscription[]
  payments              Payment[]
  invoices              Invoice[]

  // ==================== USAGE TRACKING ====================
  // Status: NOT YET IMPLEMENTED
  // Currently used for: subscription limit checks (coming soon)
  currentPeriodStart         DateTime  @default(now())
  currentPeriodEnd           DateTime?
  queuesCreatedThisMonth     Int       @default(0)
  queueItemsCreatedThisMonth Int       @default(0)
  totalOutlets               Int       @default(0)
  totalStaff                 Int       @default(0)

  // ==================== SMS TRACKING ====================
  // Status: NOT YET IMPLEMENTED
  // For SMS123 API integration
  smsCreditsRemaining Int               @default(0) // Prepaid SMS credits left
  smsSentThisMonth    Int               @default(0) // Monthly usage counter
  smsSentTotal        Int               @default(0) // Lifetime SMS sent
  smsEnabled          Boolean           @default(false) // Feature enabled/disabled
  smsApiKey           String?           @db.VarChar(500) // Encrypted SMS123 API key
  smsApiKeyAddedAt    DateTime?
  smsNotifications    SmsNotification[] // Relation to SMS logs

  @@index([slug])
  @@index([stripeCustomerId])
  @@index([subscriptionStatus])
}

enum BusinessType {
  RESTAURANT
  CLINIC
  BASIC
}

enum SubscriptionStatus {
  FREE // No paid subscription
  TRIALING // In free trial
  ACTIVE // Paid and active
  PAST_DUE // Payment failed, grace period
  CANCELED // User canceled, still active until period end
  UNPAID // Payment failed, no grace period
  INCOMPLETE // Subscription created but payment incomplete
  PAUSED // Temporarily paused
}

enum SubscriptionTier {
  FREE // Free tier with limitations
  BASIC // Basic paid tier
  PROFESSIONAL // Professional tier
  ENTERPRISE // Enterprise tier
}

// ==================== STAFF MODEL ====================
model Staff {
  id                String      @id @default(uuid())
  name              String      @db.VarChar(1000)
  nameHashed        String      @db.VarChar(255)
  role              Role        @default(TIER_3)
  createdAt         DateTime    @default(now())
  account           Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId         String
  email             String?     @unique @db.VarChar(1000)
  pfp               String?     @db.VarChar(255)
  googleId          String?
  facebookId        String?
  password          String?
  auditLogs         AuditLog[]
  createdQueueItems QueueItem[] @relation("QueueItemCreator")
  pausedByStaff     Queue[]     @relation("QueuePausedByStaff")

  staffNumber Int          @default(autoincrement())
  oauthTokens OAuthToken[]

  @@unique([accountId, staffNumber])
  @@index([accountId])
  @@index([name])
}

enum Role {
  TIER_1 // OWNER
  TIER_2 // MANAGER, ASSISTANT_MANAGER
  TIER_3 // HOST
  TIER_4 // View-only
}

// ==================== O-AUTH TOKEN MODEL ====================
model OAuthToken {
  id           String    @id @default(uuid())
  provider     Provider
  accessToken  String
  refreshToken String?
  accountId    String
  account      Account   @relation(fields: [accountId], references: [id], onDelete: SetNull)
  staffId      String?
  staff        Staff?    @relation(fields: [staffId], references: [id])
  createdAt    DateTime  @default(now())
  userAgent    String    @default("UNKNOWN")
  deviceName   String?
  lastLoggedIn DateTime?
  expiresAt    DateTime?

  @@index([accountId])
  @@index([staffId])
  @@index([accessToken])
}

enum Provider {
  LOCAL
  GOOGLE
  GITHUB
  FACEBOOK
}

// ==================== OUTLET MODEL ====================
model Outlet {
  id                 String     @id @default(uuid())
  name               String?    @db.VarChar(1000)
  account            Account    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId          String
  queues             Queue[]
  location           String?    @db.VarChar(2000)
  googleMaps         String?    @db.VarChar(255)
  wazeMaps           String?    @db.VarChar(255)
  imgUrl             String?    @db.VarChar(255)
  qrCode             String?    @db.VarChar(255)
  defaultEstWaitTime Int?
  phone              String?    @db.VarChar(1000)
  hours              String?
  auditLogs          AuditLog[]
  showPax            Boolean?   @default(true)

  outletNumber Int @default(autoincrement())

  @@unique([accountId, outletNumber])
  @@index([accountId])
}

// ==================== QUEUE MODEL ====================
model Queue {
  id            String      @id @default(uuid())
  outlet        Outlet      @relation(fields: [outletId], references: [id], onDelete: Cascade)
  outletId      String
  queueItems    QueueItem[]
  startTime     DateTime    @default(now())
  endTime       DateTime?
  active        Boolean     @default(true)
  name          String?
  account       Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId     String
  maxQueueItems Int         @default(999)

  // ==================== USAGE TRACKING ====================
  // Status: NOT YET IMPLEMENTED
  // For future option to pause queue with custom message to patients/customers
  isPaused            Boolean   @default(false)
  pauseReason         String?   @db.VarChar(1000)
  estimatedResumeTime DateTime?
  pausedAt            DateTime?
  actualResumeTime    DateTime?
  pausedByStaffId     String?
  pausedByStaff       Staff?    @relation("QueuePausedByStaff", fields: [pausedByStaffId], references: [id])

  @@index([outletId])
  @@index([accountId])
}

// ==================== CUSTOMER MODEL ====================
model Customer {
  id           String      @id @default(uuid())
  name         String?     @db.VarChar(1000)
  number       String?     @db.VarChar(1000)
  numberHashed String      @db.VarChar(255)
  VIP          Boolean     @default(true)
  queueItems   QueueItem[] @relation("CustomerQueueItem")
  account      Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId    String
  createdAt    DateTime    @default(now())

  // PDPA fields
  pdpaConsent   Boolean   @default(false)
  pdpaConsentAt DateTime?
  pdpaConsentIp String?   @db.VarChar(45)

  @@unique([number, accountId])
  @@index([accountId])
}

// ==================== QUEUE ITEM MODEL ====================
model QueueItem {
  id                  String    @id @default(uuid())
  queue               Queue     @relation(fields: [queueId], references: [id], onDelete: Cascade)
  queueId             String
  customerId          String?
  customer            Customer? @relation("CustomerQueueItem", fields: [customerId], references: [id])
  createdAt           DateTime  @default(now())
  pax                 Int
  name                String?   @db.VarChar(1000)
  contactNumber       String    @db.VarChar(1000)
  contactNumberHashed String    @db.VarChar(255)
  called              Boolean   @default(false)
  calledAt            DateTime?
  seated              Boolean   @default(false)
  seatedAt            DateTime?
  quit                Boolean   @default(false)
  quitAt              DateTime?
  noShow              Boolean   @default(false)
  noShowAt            DateTime?
  active              Boolean   @default(true)
  position            Int
  inactiveAt          DateTime?
  version             Int       @default(0)
  fcmToken            String?   @db.VarChar(255)
  secretToken         String?   @unique @default(uuid()) @db.VarChar(255)

  // PDPA fields
  pdpaConsent      Boolean   @default(false)
  pdpaConsentAt    DateTime?
  pdpaConsentIp    String?   @db.VarChar(45)
  createdByStaffId String?
  createdByStaff   Staff?    @relation("QueueItemCreator", fields: [createdByStaffId], references: [id])

  // ==================== SMS PREFERENCES ====================
  // Status: NOT IMPLEMENTED YET
  smsNotificationEnabled Boolean           @default(true) // User opted in for SMS
  smsNotifications       SmsNotification[] // All SMS sent for this queue item

  @@index([queueId])
  @@index([position])
  @@index([createdByStaffId])
}

// ==================== AUDIT LOG MODEL ====================
model AuditLog {
  id            String     @id @default(uuid())
  staffId       String?
  staff         Staff?     @relation(fields: [staffId], references: [id])
  actionType    ActionType
  actionDetails String?    @db.Text
  timestamp     DateTime   @default(now())
  account       Account    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId     String
  outletId      String?
  outlet        Outlet?    @relation(fields: [outletId], references: [id])

  // Additional tracking
  ipAddress  String? @db.VarChar(45)
  userAgent  String? @db.VarChar(500)
  isCronJob  Boolean @default(false)
  entityType String? @db.VarChar(50)
  entityId   String? @db.VarChar(255)

  @@index([staffId])
  @@index([accountId])
  @@index([outletId])
  @@index([actionType])
  @@index([timestamp])
  @@index([isCronJob])
  @@index([entityType, entityId])
}

enum ActionType {
  // Account actions
  ACCOUNT_CREATED
  ACCOUNT_UPDATED
  ACCOUNT_DELETED
  PRIVACY_POLICY_ACCEPTED

  // Staff actions
  STAFF_CREATED
  STAFF_UPDATED
  STAFF_DELETED
  STAFF_VERIFIED
  STAFF_QUEUE_ACCESS

  // Queue actions
  QUEUE_CREATED
  QUEUE_CLOSED
  QUEUE_PAUSED
  QUEUE_RESUMED
  QUEUE_ITEM_CREATED
  QUEUE_ITEM_DELETED

  // Customer actions
  CUSTOMER_CREATED
  CUSTOMER_UPDATED
  CUSTOMER_DELETED
  PDPA_CONSENT_GIVEN

  // Outlet actions
  OUTLET_CREATED
  OUTLET_UPDATED
  OUTLET_DELETED

  // Cron/System actions
  CRON_CLEANUP_OLD_QUEUE_ITEMS
  CRON_CLOSE_INACTIVE_QUEUES
  SYSTEM_ERROR
  AUDIT_LOG_CLEANUP
  AUDIT_LOG_CLEANUP_FAILED
  GDPR_DATA_CLEANUP
  GDPR_DATA_CLEANUP_FAILED
  INACTIVE_QUEUE_CLEANUP
  INACTIVE_QUEUE_CLEANUP_FAILED
  MONTHLY_USAGE_RESET

  // Payment actions
  SUBSCRIPTION_CREATED
  SUBSCRIPTION_UPDATED
  SUBSCRIPTION_CANCELED
  PAYMENT_SUCCEEDED
  PAYMENT_FAILED
  INVOICE_CREATED
  INVOICE_PAID

  // SMS actions
  SMS_SENT
  SMS_FAILED
  SMS_CREDITS_PURCHASED
  SMS_CREDITS_LOW
  SMS_API_KEY_ADDED
  SMS_API_KEY_REMOVED
}

// ==================== PAYMENT MODELS ====================
// Status: NOT YET IMPLEMENTED

model Subscription {
  id        String  @id @default(uuid())
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId String

  // Stripe fields
  stripeSubscriptionId String @unique @db.VarChar(255)
  stripePriceId        String @db.VarChar(255) // Price ID (price_xxx)
  stripeProductId      String @db.VarChar(255) // Product ID (prod_xxx)

  // Subscription details
  tier              SubscriptionTier
  status            SubscriptionStatus
  startDate         DateTime
  endDate           DateTime?
  canceledAt        DateTime?
  cancelAtPeriodEnd Boolean            @default(false)

  // Billing
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  billingCycle       BillingCycle @default(MONTHLY)
  amount             Int // Amount in cents
  currency           String       @default("sgd") @db.VarChar(3)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payments Payment[]
  invoices Invoice[]

  @@index([accountId])
  @@index([stripeSubscriptionId])
  @@index([status])
}

enum BillingCycle {
  MONTHLY
  YEARLY
  QUARTERLY
}

model Payment {
  id             String        @id @default(uuid())
  account        Account       @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId      String
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?

  // Stripe fields
  stripePaymentIntentId String  @unique @db.VarChar(255)
  stripeChargeId        String? @db.VarChar(255)
  stripeInvoiceId       String? @db.VarChar(255)

  // Payment details
  amount        Int // Amount in cents
  currency      String        @default("sgd") @db.VarChar(3)
  status        PaymentStatus
  paymentMethod String?       @db.VarChar(100) // "card", "bank_transfer", etc.

  // Card details (last 4 digits only for display)
  cardLast4 String? @db.VarChar(4)
  cardBrand String? @db.VarChar(50)

  // Metadata
  description  String?   @db.Text
  createdAt    DateTime  @default(now())
  paidAt       DateTime?
  failedAt     DateTime?
  refundedAt   DateTime?
  refundAmount Int? // Amount refunded in cents

  // Audit
  ipAddress String? @db.VarChar(45)

  @@index([accountId])
  @@index([subscriptionId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@index([createdAt])
}

enum PaymentStatus {
  PENDING // Payment initiated
  PROCESSING // Being processed
  SUCCEEDED // Successfully paid
  FAILED // Payment failed
  CANCELED // Canceled before completion
  REFUNDED // Fully refunded
  PARTIALLY_REFUNDED // Partially refunded
}

model Invoice {
  id             String        @id @default(uuid())
  account        Account       @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId      String
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?

  // Stripe fields
  stripeInvoiceId        String  @unique @db.VarChar(255)
  stripeInvoiceNumber    String? @db.VarChar(100)
  stripeInvoicePdf       String? @db.VarChar(500) // URL to PDF
  stripeHostedInvoiceUrl String? @db.VarChar(500) // URL to view invoice

  // Invoice details
  amount     Int // Total amount in cents
  amountDue  Int // Amount still owed
  amountPaid Int // Amount paid
  currency   String        @default("sgd") @db.VarChar(3)
  status     InvoiceStatus

  // Dates
  createdAt DateTime  @default(now())
  dueDate   DateTime?
  paidAt    DateTime?
  voidedAt  DateTime?

  // Period
  periodStart DateTime
  periodEnd   DateTime

  // Metadata
  description String? @db.Text

  @@index([accountId])
  @@index([subscriptionId])
  @@index([stripeInvoiceId])
  @@index([status])
  @@index([createdAt])
}

enum InvoiceStatus {
  DRAFT // Not finalized
  OPEN // Awaiting payment
  PAID // Fully paid
  VOID // Voided/canceled
  UNCOLLECTIBLE // Cannot collect payment
}

// ==================== SMS NOTIFICATION MODEL ====================
// Status: NOT YET IMPLEMENTED
model SmsNotification {
  id          String     @id @default(uuid())
  account     Account    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId   String
  queueItem   QueueItem? @relation(fields: [queueItemId], references: [id])
  queueItemId String?

  // Recipient details
  phoneNumber String @db.VarChar(20) // Encrypted
  countryCode String @default("+65") @db.VarChar(5)

  // Message details
  messageType SmsMessageType
  messageBody String         @db.Text // The actual SMS content

  // SMS Provider details (SMS123)
  providerId       String?   @db.VarChar(255) // SMS123 message ID
  providerStatus   SmsStatus @default(PENDING)
  providerResponse String?   @db.Text // Full API response (for debugging)

  // Costs and credits
  creditsCost Int @default(1) // How many credits this SMS cost

  // Timestamps
  createdAt   DateTime  @default(now())
  sentAt      DateTime? // When SMS was sent
  deliveredAt DateTime? // When SMS was delivered (if provider supports)
  failedAt    DateTime? // When SMS failed

  // Error tracking
  errorCode    String? @db.VarChar(50)
  errorMessage String? @db.VarChar(500)
  retryCount   Int     @default(0)
  maxRetries   Int     @default(3)

  // Metadata
  ipAddress String? @db.VarChar(45)
  userAgent String? @db.VarChar(500)

  @@index([accountId])
  @@index([queueItemId])
  @@index([providerStatus])
  @@index([messageType])
  @@index([createdAt])
  @@index([phoneNumber]) // For finding SMS by phone number
}

enum SmsMessageType {
  QUEUE_JOINED // "You've joined the queue. Position: #5"
  QUEUE_POSITION_UPDATE // "Your position: #3. Estimated wait: 15 mins"
  QUEUE_READY // "Your table is ready! Please proceed to the host."
  QUEUE_CALLED // "You're next! Please get ready."
  QUEUE_CANCELLED // "Your queue has been cancelled."
  QUEUE_NO_SHOW // "You were marked as no-show."
  CUSTOM_MESSAGE // Custom message from staff
  TEST_MESSAGE // Test SMS
}

enum SmsStatus {
  PENDING // Queued, not sent yet
  SENT // Successfully sent to SMS provider
  DELIVERED // SMS delivered to recipient
  FAILED // Failed to send
  REJECTED // Rejected by SMS provider (invalid number, etc.)
  EXPIRED // Message expired (couldn't deliver in time)
  UNDELIVERED // Provider confirmed non-delivery
}
